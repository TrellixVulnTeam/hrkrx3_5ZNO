"""
Classes and functions for managing network connections.

arkOS Core
(c) 2016 CitizenWeb
Written by Jacob Cook
Licensed under GPLv3, see LICENSE.md
"""

import fcntl
import netifaces
import os
import psutil
import socket
import struct

from arkos import signals
from arkos.utilities import errors, shell, netmask_to_cidr


class Connection:
    """Class to represent a network connection."""

    def __init__(self, id="", connected=False, enabled=False, config={}):
        """
        Initialize the network connection object.

        :param str id: network name
        :param bool connected: Is network connected?
        :param bool enabled: Should network connect on boot?
        :param dict config: Netctl config lines as dict
        """
        self.id = id
        self.connected = connected
        self.enabled = enabled
        self.config = config

    def add(self):
        """Add network connection."""
        signals.emit("networks", "pre_add", self)
        with open(os.path.join("/etc/netctl", self.id), "w") as f:
            is_wireless = self.config.get("connection") == "wireless"
            is_static = self.config.get("addressing") == "static"
            f.write("# automatically generated by arkOS\n")
            if self.config.get("connection"):
                f.write("Connection=\"" + self.config["connection"] + "\"\n")
            if self.config.get("description"):
                f.write("Description=\"" + self.config["description"] + "\"\n")
            if self.config.get("interface"):
                f.write("Interface=\"" + self.config["interface"] + "\"\n")
            if self.config.get("security") and is_wireless:
                f.write("Security=\"" + self.config["security"] + "\"\n")
            if self.config.get("essid") and is_wireless:
                f.write("ESSID=\"" + self.config["essid"] + "\"\n")
            if self.config.get("addressing"):
                f.write("IP=\"" + self.config["addressing"] + "\"\n")
            if self.config.get("address") and is_static:
                f.write("Address=(\"" + self.config["address"] + "\")\n")
            if self.config.get("gateway") and is_static:
                f.write("Gateway=\"" + self.config["gateway"] + "\"\n")
            if self.config.get("key") and is_wireless:
                f.write("Key=\"" + self.config["key"] + "\"\n")
        signals.emit("networks", "post_add", self)

    def update(self):
        """Update network connection with object properties."""
        connected = self.connected
        if connected:
            self.disconnect()
        self.add()
        if connected:
            self.connect()

    def remove(self):
        """Remove network connection."""
        signals.emit("networks", "pre_remove", self)
        if os.path.exists(os.path.join("/etc/netctl", self.id)):
            os.unlink(os.path.join("/etc/netctl", self.id))
        signals.emit("networks", "post_remove", self)

    def connect(self):
        """Connect to network."""
        signals.emit("networks", "pre_connect", self)
        for x in get_connections(iface=self.config.get("interface")):
            x.disconnect()
        s = shell("netctl start {0}".format(self.id))
        if s["code"] == 0:
            self.connected = True
            signals.emit("networks", "post_connect", self)
        else:
            raise errors.OperationFailedError("Network connection failed")

    def disconnect(self):
        """Disconnect from network."""
        signals.emit("networks", "pre_disconnect", self)
        s = shell("netctl stop {0}".format(self.id))
        if s["code"] == 0:
            self.connected = False
            signals.emit("networks", "post_disconnect", self)
        else:
            raise errors.OperationFailedError("Network disconnection failed")

    def toggle(self):
        """Toggle network state."""
        if self.connected:
            self.disconnect()
        else:
            self.connect()

    def enable(self):
        """Enable connection on boot."""
        s = shell("netctl enable {0}".format(self.id))
        if s["code"] == 0:
            self.enabled = True
        else:
            raise errors.OperationFailedError("Network enable failed")

    def disable(self):
        """Disable connection on boot."""
        s = shell("netctl disable {0}".format(self.id))
        if s["code"] == 0:
            self.enabled = False
        else:
            raise errors.OperationFailedError("Network disable failed")

    @property
    def as_dict(self):
        """Return network metadata as dict."""
        return {
            "id": self.id,
            "connected": self.connected,
            "enabled": self.enabled,
            "config": self.config,
            "is_ready": True
        }

    @property
    def serialized(self):
        """Return serializable network metadata as dict."""
        return self.as_dict


class Interface:
    """Class to represent a network connection."""

    def __init__(self, id="", itype="", up=False, ip=[], rx=0, tx=0):
        """
        Initialize the network interface object.

        :param str id: network interface name
        :param str itype: interface type ("ethernet", "wireless", etc)
        :param bool up: Is interface up?
        :param list ip: list of IP addresses assigned to this interface
        :param int rx: Number of bytes received
        :param int tx: Number of bytes sent
        """
        self.id = id
        self.itype = itype
        self.up = up
        self.ip = ip
        self.rx = rx
        self.tx = tx

    def bring_up(self):
        """Bring interface up."""
        shell("ip link set dev {0} up".format(self.id))

    def bring_down(self):
        """Bring interface down."""
        shell("ip link set dev {0} down".format(self.id))

    def enable(self):
        """Bring interface up on boot."""
        shell("systemctl enable netctl-auto@{0}.service".format(self.id))

    def disable(self):
        """Don't bring interface up on boot."""
        shell("systemctl disable netctl-auto@{0}.service".format(self.id))

    @property
    def as_dict(self):
        """Return interface metadata as dict."""
        return {
            "id": self.id,
            "type": self.itype,
            "up": self.up,
            "ip": self.ip,
            "rx": self.rx,
            "tx": self.tx
        }

    @property
    def serialized(self):
        """Return serializable interface metadata as dict."""
        return self.as_dict


def get_connections(id=None, iface=None):
    """
    Get list of network connections.

    :param str id: Filter by network connection name

    :param str iface: Filter by network interface name
    :returns: Connection(s)
    :rtype: Connection or list thereof
    """
    conns = []
    netctl = shell("netctl list")
    for line in netctl["stdout"].split(b"\n"):
        if not line.split():
            continue
        svc = "/etc/systemd/system/multi-user.target.wants/netctl@{0}.service"
        enabled = os.path.exists(svc.format(line[2:]))
        c = Connection(line[2:].decode(), line.startswith(b"*"), enabled)
        with open(os.path.join("/etc/netctl", c.id), "r") as f:
            data = f.readlines()
        for x in data:
            if x.startswith("#") or not x.strip():
                continue
            parse = x.split("=")
            to_trans = dict.fromkeys(map(ord, "()\"\"\n"), None)
            c.config[parse[0].lower()] = parse[1].translate(to_trans)
        if id == c.id:
            return c
        if not iface or c.config.get("interface") == iface:
            conns.append(c)
    return conns if not id else None


def get_interfaces(id=None):
    """
    Get list of network interfaces.

    :param str id: Filter by network interface name
    :returns: Interface(s)
    :rtype: Interface or list thereof
    """
    ifaces = []
    for x in netifaces.interfaces():
        # Classify the interface type
        if x[:-1] in ["ppp", "wvdial"]:
            itype = "ppp"
        elif x[:2] in ["wl", "ra", "wi", "at"]:
            itype = "wireless"
        elif x[:2].lower() == "br":
            itype = "bridge"
        elif x[:2].lower() == "tu":
            itype = "tunnel"
        elif x.lower() == "lo":
            itype = "loopback"
        elif x[:2] in ["et", "en"]:
            itype = "ethernet"
        else:
            itype = "unknown"
        i = Interface(id=x, itype=itype)
        # Get the total bytes in and out for this interface
        data = psutil.net_io_counters(pernic=True)
        data = data[x] if type(data) == dict else data
        i.rx, i.tx = data[0], data[1]
        addrs = netifaces.ifaddresses(x)
        i.ip = addrs.get(netifaces.AF_INET, [])
        i.ip6 = addrs.get(netifaces.AF_INET6, [])
        if not i.ip and not i.ip6:
            i.up = False
            continue
        # Determine if the interface is up or not
        s = socket.socket(socket.AF_INET if i.ip else socket.AF_INET6,
                          socket.SOCK_DGRAM)
        r = fcntl.ioctl(s.fileno(), 0x8913, i.id + ("\0"*256))
        flags, = struct.unpack("H", r[16:18])
        up = flags & 1
        s.close()
        i.up = up == 1
        if id == i.id:
            return i
        ifaces.append(i)
    return ifaces if not id else None


def get_active_ranges():
    """
    Get local IP address ranges of connected networks.

    :returns: list of IP address ranges
    """
    ranges = []
    for x in get_interfaces():
        for y in x.ip:
            if "127.0.0.1" in y["addr"] or "0.0.0.0" in y["addr"]:
                continue
            ri = y["addr"].split(".")
            ri[3] = "0"
            ri = ".".join(ri)
            y = ri + "/" + str(netmask_to_cidr(y["netmask"]))
            ranges.append(y)
    return ranges
